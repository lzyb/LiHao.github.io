{"meta":{"title":"李昊的站","subtitle":null,"description":"李导师的博客","author":"Li Hao","url":"https://lzyb.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-04-28T12:53:14.000Z","updated":"2020-04-29T06:09:13.740Z","comments":true,"path":"categories/index.html","permalink":"https://lzyb.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-04-28T12:56:00.000Z","updated":"2020-04-29T06:09:13.741Z","comments":true,"path":"tags/index.html","permalink":"https://lzyb.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2020-04-28T13:04:56.000Z","updated":"2020-05-08T09:10:13.610Z","comments":true,"path":"about/index.html","permalink":"https://lzyb.github.io/about/index.html","excerpt":"","text":"做个有趣的人......"}],"posts":[{"title":"吟诗一首","slug":"2020/04/26随笔","date":"2020-04-26T13:32:42.000Z","updated":"2020-05-06T09:37:24.648Z","comments":true,"path":"2020/04/26/2020/04/26随笔/","link":"","permalink":"https://lzyb.github.io/2020/04/26/2020/04/26%E9%9A%8F%E7%AC%94/","excerpt":"三十而立已到中年，技术平平且不善言辞。 ​每逢面试十面九散，未来何期也诚惶诚恐。","text":"三十而立已到中年，技术平平且不善言辞。 ​每逢面试十面九散，未来何期也诚惶诚恐。 数十余年人在漂泊，碌碌无为还不知不觉。 ​二零一九新冠肺炎，方然顿悟欲难欲要抗。 便是一生无功与名，愿为妻儿换一世太平。 摘自V2EX有感","categories":[{"name":"生活","slug":"生活","permalink":"https://lzyb.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://lzyb.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Git常用命令","slug":"Git常用命令","date":"2017-05-13T07:32:08.000Z","updated":"2020-05-15T03:29:19.434Z","comments":true,"path":"2017/05/13/Git常用命令/","link":"","permalink":"https://lzyb.github.io/2017/05/13/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"常用Git命令git init [project-name] 初始化 在工作路径上创建主分支git config [--global] user.name &quot;[name]&quot; 设置提交代码时的用户信息git config [--global] user.email &quot;[email address]&quot;设置提交代码时的用户信息git clone [地址] 克隆远程仓库git clone -b [分支名] [地址] 克隆分支的代码到本地git add -A 保存所有的修改git add . 保存新的添加和修改，但是不包括删除git add -u 保存修改和删除，但是不包括新建文件。所以默认使用git add -A就行git commit –m “本次提交描述” commit可以一次提交缓冲区的所有文件，相当于一个版本。git pull origin [分支名] 从指定分支获取最新迭代git push origin [分支名] 推送当前迭代到制动分支","text":"常用Git命令git init [project-name] 初始化 在工作路径上创建主分支git config [--global] user.name &quot;[name]&quot; 设置提交代码时的用户信息git config [--global] user.email &quot;[email address]&quot;设置提交代码时的用户信息git clone [地址] 克隆远程仓库git clone -b [分支名] [地址] 克隆分支的代码到本地git add -A 保存所有的修改git add . 保存新的添加和修改，但是不包括删除git add -u 保存修改和删除，但是不包括新建文件。所以默认使用git add -A就行git commit –m “本次提交描述” commit可以一次提交缓冲区的所有文件，相当于一个版本。git pull origin [分支名] 从指定分支获取最新迭代git push origin [分支名] 推送当前迭代到制动分支 git status 查看状态git push -- force 强制推送 分支命令git branch 查看当前分支git branch [分支名] 新建分支git checkout [分支名] 切换分支git checkout -b [分支名] 创建并切换分支git branch -v 查看分支以及提交hash值和commit信息git merge [分支名] 把该分支的内容合并到现有分支上git branch -d [分支名] 删除分支git branch -D [分支名] 强制删除 若没有其他分支合并就删除 d会提示 D不会git branch -m [旧分支名] [新分支名] 修改分支名git branch -M [旧分支名] [新分支名] 修改分支名 M强制修改 若与其他分支有冲突也会创建(慎用)git branch -r // 列出远程分支(远程所有分支名)git branch -a // 查看远程分支(列出远程分支以及本地分支名)git fetch 更新remote索引git push -u origin [分支名] 将本地分支推送到origin主机，同时指定origin为默认主机","categories":[{"name":"Git","slug":"Git","permalink":"https://lzyb.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://lzyb.github.io/tags/Git/"},{"name":"常用命令","slug":"常用命令","permalink":"https://lzyb.github.io/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"}]},{"title":"Java8 Stream流","slug":"Java8-Stream流","date":"2017-05-11T02:01:04.000Z","updated":"2020-05-11T07:53:31.502Z","comments":true,"path":"2017/05/11/Java8-Stream流/","link":"","permalink":"https://lzyb.github.io/2017/05/11/Java8-Stream%E6%B5%81/","excerpt":"Java 8 Stream流Java 8 Stream流概述虽然JAVA8中的stream API与JAVA I/O中的InputStream和OutputStream在名字上比较类似，但是其实是另外一个东西，Stream API是JAVA函数式编程中的一个重要组成部分。","text":"Java 8 Stream流Java 8 Stream流概述虽然JAVA8中的stream API与JAVA I/O中的InputStream和OutputStream在名字上比较类似，但是其实是另外一个东西，Stream API是JAVA函数式编程中的一个重要组成部分。 Streams如何工作？stream是一个可以对单列集合中的元素执行各种计算操作的一个元素序列。 1234567891011public static void main(String[] args) &#123;List&lt;String&gt; myList = Arrays.asList(\"a1\", \"a2\", \"b1\", \"c2\", \"c1\");myList.stream() .filter(s -&gt; s.startsWith(\"c\")) .map(String::toUpperCase) .sorted() .forEach(System.out::println); // C1 // C2&#125; stream包含中间（intermediate operations）和最终（terminal operation）两种形式的操作。中间操作（intermediate operations）的返回值还是一个stream，因此可以通过链式调用将中间操作（intermediate operations）串联起来。最终操作（terminal operation）只能返回void或者一个非stream的结果。在上述例子中：filter, map ，sorted是中间操作，而forEach是一个最终操作。更多关于stream的中可用的操作可以查看java doc。上面例子中的链式调用也被称为操作管道流。 大多数流操作都接受某种lambda表达式参数，这是一个指定操作确切行为的功能接口。这些操作大多数都必须是无干扰的和无状态的。这意味着什么？ 当函数不修改流的基础数据源时，它是无干扰的，例如，在上面的示例中，没有lambda表达式myList通过添加或删除集合中的元素来进行修改。 当操作的执行是确定性的时，函数是无状态的，例如，在上面的示例中，lambda表达式不依赖于外部变量的任何可变变量或状态，这些变量或状态可能在执行期间发生变化。 不同类型的流可以从各种数据源（尤其是集合）创建流。列表和集合支持新方法，stream()并parallelStream()可以创建顺序流或并行流。并行流能够在多个线程上运行，并且将在本教程的后续部分中介绍。现在，我们关注顺序流： 1234Arrays.asList(\"a1\", \"a2\", \"a3\") .stream() .findFirst() .ifPresent(System.out::println); // a1 stream()在对象列表上调用该方法将返回常规对象流。但是我们不必创建集合即可使用流，如我们在下一个代码示例中看到的那样： 123Stream.of(\"a1\", \"a2\", \"a3\") .findFirst() .ifPresent(System.out::println); // a1 仅用于Stream.of()从一堆对象引用创建流。 除了常规对象流之外，Java 8还附带了特殊的流，用于处理原始数据类型int，long以及double。您可能已经猜到了IntStream，LongStream和DoubleStream。 IntStreams可以使用以下方法替换常规的for循环IntStream.range()： 123456IntStream.range(1, 4) .forEach(System.out::println);// 1// 2// 3 所有这些原始流都像常规对象流一样工作，但有以下区别：原始流使用专用的lambda表达式，例如IntFunction代替Function或IntPredicate代替Predicate。基本流支持其他终端聚合操作sum()和average()： 1234Arrays.stream(new int[] &#123;1, 2, 3&#125;) .map(n -&gt; 2 * n + 1) .average() .ifPresent(System.out::println); // 5.0 有时将常规对象流转换为原始流很有用，反之亦然。为此，对象流支持特殊的映射操作mapToInt()，mapToLong()并且mapToDouble： 12345Stream.of(\"a1\", \"a2\", \"a3\") .map(s -&gt; s.substring(1)) .mapToInt(Integer::parseInt) .max() .ifPresent(System.out::println); // 3 原始流可以通过以下方式转换为对象流mapToObj()： 1234567IntStream.range(1, 4) .mapToObj(i -&gt; \"a\" + i) .forEach(System.out::println);// a1// a2// a3 这是一个组合的示例：双精度流首先映射到int流，然后映射到字符串对象流： 12345678Stream.of(1.0, 2.0, 3.0) .mapToInt(Double::intValue) .mapToObj(i -&gt; \"a\" + i) .forEach(System.out::println);// a1// a2// a3 处理订单号既然我们已经学习了如何创建和使用不同类型的流，那么让我们更深入地了解如何在后台处理流操作。 中间操作的一个重要特征是懒惰。查看以下缺少终端操作的示例： 12345Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .filter(s -&gt; &#123; System.out.println(\"filter: \" + s); return true; &#125;); 执行此代码段时，没有任何内容打印到控制台。这是因为仅当存在终端操作时才执行中间操作。 让我们通过终端操作扩展以上示例forEach： 1234567Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .filter(s -&gt; &#123; System.out.println(\"filter: \" + s); return true; &#125;) .forEach(s -&gt; System.out.println(\"forEach: \" + s));执行此代码段将在控制台上产生所需的输出： 12345678910filter: d2forEach: d2filter: a2forEach: a2filter: b1forEach: b1filter: b3forEach: b3filter: cforEach: c 结果的顺序可能令人惊讶。天真的方法是在流的所有元素上一个接一个地水平执行操作。但是，每个元素都沿链垂直移动。然后，第一个字符串“ d2”通过，filter然后forEach才处理第二个字符串“ a2”。 这种行为可以减少在每个元素上执行的实际操作数，如下例所示： 1234567891011121314Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .map(s -&gt; &#123; System.out.println(\"map: \" + s); return s.toUpperCase(); &#125;) .anyMatch(s -&gt; &#123; System.out.println(\"anyMatch: \" + s); return s.startsWith(\"A\"); &#125;);// map: d2// anyMatch: D2// map: a2// anyMatch: A2 谓词应用于给定输入元素后，该操作anyMatch将true立即返回。对于通过“ A2”的第二个元素，这是正确的。由于流链是垂直执行的，map因此在这种情况下只需执行两次。因此，map将尽可能少地调用而不是映射流的所有元素。 为什么为了事项下一个示例包括两个中间操作map和filter和终端操作forEach。让我们再次检查这些操作是如何执行的： 12345678910111213141516171819202122Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .map(s -&gt; &#123; System.out.println(\"map: \" + s); return s.toUpperCase(); &#125;) .filter(s -&gt; &#123; System.out.println(\"filter: \" + s); return s.startsWith(\"A\"); &#125;) .forEach(s -&gt; System.out.println(\"forEach: \" + s));// map: d2// filter: D2// map: a2// filter: A2// forEach: A2// map: b1// filter: B1// map: b3// filter: B3// map: c// filter: C 您可能已经猜到了两者，map并且filter基础集合中的每个字符串都被调用了五次，而forEach仅被调用了一次。 如果更改操作顺序（移至filter链的开头），则可以大大减少实际的执行次数： 123456789101112131415161718Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .filter(s -&gt; &#123; System.out.println(\"filter: \" + s); return s.startsWith(\"a\"); &#125;) .map(s -&gt; &#123; System.out.println(\"map: \" + s); return s.toUpperCase(); &#125;) .forEach(s -&gt; System.out.println(\"forEach: \" + s));// filter: d2// filter: a2// map: a2// forEach: A2// filter: b1// filter: b3// filter: c 现在，map仅调用一次，因此操作管道对于大量输入元素的执行速度要快得多。组成复杂的方法链时，请记住这一点。 让我们通过一个额外的操作扩展上述示例sorted： 1234567891011121314Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .sorted((s1, s2) -&gt; &#123; System.out.printf(\"sort: %s; %s\\n\", s1, s2); return s1.compareTo(s2); &#125;) .filter(s -&gt; &#123; System.out.println(\"filter: \" + s); return s.startsWith(\"a\"); &#125;) .map(s -&gt; &#123; System.out.println(\"map: \" + s); return s.toUpperCase(); &#125;) .forEach(s -&gt; System.out.println(\"forEach: \" + s)); 排序是一种特殊的中间操作。这是所谓的有状态操作，因为为了对元素集合进行排序，您必须在排序期间保持状态。 执行此示例将得到以下控制台输出： 123456789101112131415sort: a2; d2sort: b1; a2sort: b1; d2sort: b1; a2sort: b3; b1sort: b3; d2sort: c; b3sort: c; d2filter: a2map: a2forEach: A2filter: b1filter: b3filter: cfilter: d2 首先，对整个输入集合执行排序操作。换句话说，sorted是水平执行的。因此，在这种情况下sorted，对输入集合中每个元素的多个组合调用了八次。 我们可以通过重新排序链来再次优化性能： 12345678910111213141516171819202122Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .filter(s -&gt; &#123; System.out.println(\"filter: \" + s); return s.startsWith(\"a\"); &#125;) .sorted((s1, s2) -&gt; &#123; System.out.printf(\"sort: %s; %s\\n\", s1, s2); return s1.compareTo(s2); &#125;) .map(s -&gt; &#123; System.out.println(\"map: \" + s); return s.toUpperCase(); &#125;) .forEach(s -&gt; System.out.println(\"forEach: \" + s));// filter: d2// filter: a2// filter: b1// filter: b3// filter: c// map: a2// forEach: A2 在此示例sorted中，因为filter将输入集合简化为一个元素而从未被调用。因此，对于较大的输入集合，性能会大大提高。 重用流Java 8流无法重用。调用任何终端操作后，流就立即关闭： 123456Stream&lt;String&gt; stream = Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .filter(s -&gt; s.startsWith(\"a\"));stream.anyMatch(s -&gt; true); // okstream.noneMatch(s -&gt; true); // exception 在同一流上调用noneMatchafter会anyMatch导致以下异常： 12345java.lang.IllegalStateException: stream has already been operated upon or closed at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:229) at java.util.stream.ReferencePipeline.noneMatch(ReferencePipeline.java:459) at com.winterbe.java8.Streams5.test7(Streams5.java:38) at com.winterbe.java8.Streams5.main(Streams5.java:28) 为了克服此限制，我们必须为要执行的每个终端操作创建一个新的流链，例如，我们可以创建一个流提供程序以构造一个已经设置了所有中间操作的新流： 123456Supplier&lt;Stream&lt;String&gt;&gt; streamSupplier = () -&gt; Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .filter(s -&gt; s.startsWith(\"a\"));streamSupplier.get().anyMatch(s -&gt; true); // okstreamSupplier.get().noneMatch(s -&gt; true); // ok 每次调用都会get()构造一个新的流，我们可以保存该流以调用所需的终端操作。 高级操作流支持许多不同的操作。我们已经了解了最重要的操作，例如filter或map。我留给您发现所有其他可用的操作（请参阅Stream Javadoc）。相反，让我们更深入地了解了更复杂的操作collect，flatMap和reduce。 本节中的大多数代码示例都使用以下人员进行演示： 123456789101112131415161718192021class Person &#123; String name; int age; Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return name; &#125;&#125;List&lt;Person&gt; persons = Arrays.asList( new Person(\"Max\", 18), new Person(\"Peter\", 23), new Person(\"Pamela\", 23), new Person(\"David\", 12)); 收集收集是到流中的元素转换为不同的种类的结果，例如一个非常有用的终端操作List，Set或Map。收集接受Collector由四个不同的操作组成的：供应商，累加器，合并器和装订器。乍一看，这听起来超级复杂，但是好地方是Java 8通过Collectors该类支持各种内置的收集器。因此，对于最常见的操作，您不必自己实现收集器。 让我们从一个非常常见的用例开始： 1234567List&lt;Person&gt; filtered = persons .stream() .filter(p -&gt; p.name.startsWith(\"P\")) .collect(Collectors.toList());System.out.println(filtered); // [Peter, Pamela] 如您所见，从流的元素构造列表非常简单。需要一个集合而不是列表-只需使用Collectors.toSet()。 下一个示例按年龄对所有人进行分组： 12345678910Map&lt;Integer, List&lt;Person&gt;&gt; personsByAge = persons .stream() .collect(Collectors.groupingBy(p -&gt; p.age));personsByAge .forEach((age, p) -&gt; System.out.format(\"age %s: %s\\n\", age, p));// age 18: [Max]// age 23: [Peter, Pamela]// age 12: [David] 收集器功能极为丰富。您还可以在信息流的元素上创建汇总，例如，确定所有人的平均年龄： 12345Double averageAge = persons .stream() .collect(Collectors.averagingInt(p -&gt; p.age));System.out.println(averageAge); // 19.0 如果您对更全面的统计感兴趣，则汇总收集器将返回一个特殊的内置汇总统计对象。因此，我们可以简单地确定人员的最小，最大和算术平均年龄以及总数和计数。 1234567IntSummaryStatistics ageSummary = persons .stream() .collect(Collectors.summarizingInt(p -&gt; p.age));System.out.println(ageSummary);// IntSummaryStatistics&#123;count=4, sum=76, min=12, average=19.000000, max=23&#125; 下一个示例将所有人连接成一个字符串： 12345678String phrase = persons .stream() .filter(p -&gt; p.age &gt;= 18) .map(p -&gt; p.name) .collect(Collectors.joining(\" and \", \"In Germany \", \" are of legal age.\"));System.out.println(phrase);// In Germany Max and Peter and Pamela are of legal age. 联接收集器接受定界符以及可选的前缀和后缀。 为了将流元素转换为映射，我们必须指定如何映射键和值。请记住，映射的键必须唯一，否则将IllegalStateException抛出。您可以选择将合并功能作为附加参数传递来绕过异常： 123456789Map&lt;Integer, String&gt; map = persons .stream() .collect(Collectors.toMap( p -&gt; p.age, p -&gt; p.name, (name1, name2) -&gt; name1 + \";\" + name2));System.out.println(map);// &#123;18=Max, 23=Peter;Pamela, 12=David&#125; 现在我们知道一些最强大的内置收集器，让我们尝试构建自己的特殊收集器。我们希望将流中的所有人转换为单个字符串，该字符串包含所有用|竖线字符分隔的大写字母名称。为了实现这一点，我们通过创建了一个新的收集器Collector.of()。我们必须通过收集器的四个要素：供应商，累加器，组合器和修整器。 123456789101112Collector&lt;Person, StringJoiner, String&gt; personNameCollector = Collector.of( () -&gt; new StringJoiner(\" | \"), // supplier (j, p) -&gt; j.add(p.name.toUpperCase()), // accumulator (j1, j2) -&gt; j1.merge(j2), // combiner StringJoiner::toString); // finisherString names = persons .stream() .collect(personNameCollector);System.out.println(names); // MAX | PETER | PAMELA | DAVID 由于Java中的字符串是不可变的，因此我们需要一个帮助器类，StringJoiner以便让收集器构造我们的字符串。供应商最初使用适当的定界符构造此类StringJoiner。累加器用于将每个人的大写名称添加到StringJoiner。组合器知道如何将两个StringJoiners合并为一个。在最后一步，修整器从StringJoiner构造所需的String。 FlatMap我们已经学习了如何通过使用map操作将流的对象转换为另一种对象。映射是有限的，因为每个对象只能精确地映射到另一个对象。但是，如果我们想将一个对象转换成多个其他对象，或者根本不转换呢？这就是flatMap救援的地方。 FlatMap将流的每个元素转换为其他对象的流。因此，每个对象都将转换为零，一个或多个由流支持的其他对象。然后，将这些流的内容放入flatMap操作的返回流中。 在看到flatMap实际效果之前，我们需要一个适当的类型层次结构： 12345678910111213141516class Foo &#123; String name; List&lt;Bar&gt; bars = new ArrayList&lt;&gt;(); Foo(String name) &#123; this.name = name; &#125;&#125;class Bar &#123; String name; Bar(String name) &#123; this.name = name; &#125;&#125; 接下来，我们利用关于流的知识来实例化几个对象： 123456789101112List&lt;Foo&gt; foos = new ArrayList&lt;&gt;();// create foosIntStream .range(1, 4) .forEach(i -&gt; foos.add(new Foo(\"Foo\" + i)));// create barsfoos.forEach(f -&gt; IntStream .range(1, 4) .forEach(i -&gt; f.bars.add(new Bar(\"Bar\" + i + \" &lt;- \" + f.name)))); 现在我们有了三个foo的列表，每个foo包含三个小节。 FlatMap接受一个必须返回对象流的函数。因此，为了解析每个foo的bar对象，我们只需传递适当的函数： 12345678910111213foos.stream() .flatMap(f -&gt; f.bars.stream()) .forEach(b -&gt; System.out.println(b.name));// Bar1 &lt;- Foo1// Bar2 &lt;- Foo1// Bar3 &lt;- Foo1// Bar1 &lt;- Foo2// Bar2 &lt;- Foo2// Bar3 &lt;- Foo2// Bar1 &lt;- Foo3// Bar2 &lt;- Foo3// Bar3 &lt;- Foo3 如您所见，我们已经成功地将三个foo对象的流转换为九个bar对象的流。 最后，以上代码示例可以简化为单个流操作管道： 1234567IntStream.range(1, 4) .mapToObj(i -&gt; new Foo(\"Foo\" + i)) .peek(f -&gt; IntStream.range(1, 4) .mapToObj(i -&gt; new Bar(\"Bar\" + i + \" &lt;- \" f.name)) .forEach(f.bars::add)) .flatMap(f -&gt; f.bars.stream()) .forEach(b -&gt; System.out.println(b.name)); FlatMap也可用于Optional Java 8中引入的类。Optionals flatMap操作返回另一种类型的可选对象。因此，它可以用来防止令人讨厌的null检查。 考虑这样一个高度分层的结构： 1234567891011class Outer &#123; Nested nested;&#125;class Nested &#123; Inner inner;&#125;class Inner &#123; String foo;&#125; 为了解析foo外部实例的内部字符串，您必须添加多个null检查以防止可能的NullPointerExceptions： 1234Outer outer = new Outer();if (outer != null &amp;&amp; outer.nested != null &amp;&amp; outer.nested.inner != null) &#123; System.out.println(outer.nested.inner.foo);&#125; 通过使用可选flatMap操作可以获得相同的行为： 12345Optional.of(new Outer()) .flatMap(o -&gt; Optional.ofNullable(o.nested)) .flatMap(n -&gt; Optional.ofNullable(n.inner)) .flatMap(i -&gt; Optional.ofNullable(i.foo)) .ifPresent(System.out::println); 每次调用时，如果存在或不存在，则flatMap返回一个Optional包装所需对象的包装null。 减少归约运算将流的所有元素组合为单个结果。Java 8支持三种不同的reduce方法。第一个将元素流简化为该流的一个元素。让我们看看如何使用此方法确定最大的人： 1234persons .stream() .reduce((p1, p2) -&gt; p1.age &gt; p2.age ? p1 : p2) .ifPresent(System.out::println); // Pamela 该reduce方法接受BinaryOperator累加器功能。BiFunction在这种情况下，实际上这是两个操作数共享相同类型的地方Person。BiFunction就像，Function但是接受两个参数。示例函数比较两个人的年龄，以便返回最大年龄的人。 第二种reduce方法接受身份值和BinaryOperator累加器。可使用此方法来构造一个新人员，并使用流中所有其他人员的姓名和年龄进行汇总： 1234567891011Person result = persons .stream() .reduce(new Person(\"\", 0), (p1, p2) -&gt; &#123; p1.age += p2.age; p1.name += p2.name; return p1; &#125;);System.out.format(\"name=%s; age=%s\", result.name, result.age);// name=MaxPeterPamelaDavid; age=76 第三种reduce方法接受三个参数：标识值，BiFunction累加器和type的组合器函数BinaryOperator。由于身份值类型不限于该Person类型，因此我们可以利用此归约法确定所有人的年龄总和： 12345Integer ageSum = persons .stream() .reduce(0, (sum, p) -&gt; sum += p.age, (sum1, sum2) -&gt; sum1 + sum2);System.out.println(ageSum); // 76 如您所见，结果是76，但是到底发生了什么？让我们通过一些调试输出扩展上面的代码： 12345678910111213141516Integer ageSum = persons .stream() .reduce(0, (sum, p) -&gt; &#123; System.out.format(\"accumulator: sum=%s; person=%s\\n\", sum, p); return sum += p.age; &#125;, (sum1, sum2) -&gt; &#123; System.out.format(\"combiner: sum1=%s; sum2=%s\\n\", sum1, sum2); return sum1 + sum2; &#125;);// accumulator: sum=0; person=Max// accumulator: sum=18; person=Peter// accumulator: sum=41; person=Pamela// accumulator: sum=64; person=David 如您所见，累加器功能完成了所有工作。首先使用初始标识值0和第一人称Max进行调用。在接下来的三个步骤中sum，根据最后一个步骤的年龄，人员不断增加，总年龄达到76岁。 等待扫管?？组合器永远不会被调用？并行执行相同的流将揭秘： 12345678910111213141516171819Integer ageSum = persons .parallelStream() .reduce(0, (sum, p) -&gt; &#123; System.out.format(\"accumulator: sum=%s; person=%s\\n\", sum, p); return sum += p.age; &#125;, (sum1, sum2) -&gt; &#123; System.out.format(\"combiner: sum1=%s; sum2=%s\\n\", sum1, sum2); return sum1 + sum2; &#125;);// accumulator: sum=0; person=Pamela// accumulator: sum=0; person=David// accumulator: sum=0; person=Max// accumulator: sum=0; person=Peter// combiner: sum1=18; sum2=23// combiner: sum1=23; sum2=12// combiner: sum1=41; sum2=35 并行执行此流将导致完全不同的执行行为。现在实际上调用了合并器。由于累加器是并行调用的，因此需要组合器来汇总单独的累加值。 在下一章中，让我们更深入地研究并行流。 并行数据流可以并行执行流，以提高大量输入元素上的运行时性能。并行流使用ForkJoinPool可通过静态ForkJoinPool.commonPool()方法获得的公共变量。基础线程池的大小最多使用五个线程-取决于可用物理CPU内核的数量： 12ForkJoinPool commonPool = ForkJoinPool.commonPool();System.out.println(commonPool.getParallelism()); // 3 在我的机器上，默认情况下，公共池的并行度为3。可以通过设置以下JVM参数来减小或增大此值： 1-Djava.util.concurrent.ForkJoinPool.common.parallelism=5 集合支持parallelStream()创建元素并行流的方法。或者，您可以parallel()在给定流上调用中间方法，以将顺序流转换为并行对应流。 为了低估并行流的并行执行行为，下一个示例将有关当前线程的信息打印到sout： 1234567891011121314Arrays.asList(\"a1\", \"a2\", \"b1\", \"c2\", \"c1\") .parallelStream() .filter(s -&gt; &#123; System.out.format(\"filter: %s [%s]\\n\", s, Thread.currentThread().getName()); return true; &#125;) .map(s -&gt; &#123; System.out.format(\"map: %s [%s]\\n\", s, Thread.currentThread().getName()); return s.toUpperCase(); &#125;) .forEach(s -&gt; System.out.format(\"forEach: %s [%s]\\n\", s, Thread.currentThread().getName())); 通过研究调试输出，我们应该更好地了解哪些线程实际用于执行流操作： 123456789101112131415filter: b1 [main]filter: a2 [ForkJoinPool.commonPool-worker-1]map: a2 [ForkJoinPool.commonPool-worker-1]filter: c2 [ForkJoinPool.commonPool-worker-3]map: c2 [ForkJoinPool.commonPool-worker-3]filter: c1 [ForkJoinPool.commonPool-worker-2]map: c1 [ForkJoinPool.commonPool-worker-2]forEach: C2 [ForkJoinPool.commonPool-worker-3]forEach: A2 [ForkJoinPool.commonPool-worker-1]map: b1 [main]forEach: B1 [main]filter: a1 [ForkJoinPool.commonPool-worker-3]map: a1 [ForkJoinPool.commonPool-worker-3]forEach: A1 [ForkJoinPool.commonPool-worker-3]forEach: C1 [ForkJoinPool.commonPool-worker-2] 如您所见，并行流利用通用中所有可用线程ForkJoinPool来执行流操作。在连续运行中，输出可能会有所不同，因为实际使用特定线程的行为是不确定的。 让我们通过附加的流操作扩展该示例sort： 12345678910111213141516171819Arrays.asList(\"a1\", \"a2\", \"b1\", \"c2\", \"c1\") .parallelStream() .filter(s -&gt; &#123; System.out.format(\"filter: %s [%s]\\n\", s, Thread.currentThread().getName()); return true; &#125;) .map(s -&gt; &#123; System.out.format(\"map: %s [%s]\\n\", s, Thread.currentThread().getName()); return s.toUpperCase(); &#125;) .sorted((s1, s2) -&gt; &#123; System.out.format(\"sort: %s &lt;&gt; %s [%s]\\n\", s1, s2, Thread.currentThread().getName()); return s1.compareTo(s2); &#125;) .forEach(s -&gt; System.out.format(\"forEach: %s [%s]\\n\", s, Thread.currentThread().getName())); 起初结果可能看起来很奇怪： 123456789101112131415161718192021filter: c2 [ForkJoinPool.commonPool-worker-3]filter: c1 [ForkJoinPool.commonPool-worker-2]map: c1 [ForkJoinPool.commonPool-worker-2]filter: a2 [ForkJoinPool.commonPool-worker-1]map: a2 [ForkJoinPool.commonPool-worker-1]filter: b1 [main]map: b1 [main]filter: a1 [ForkJoinPool.commonPool-worker-2]map: a1 [ForkJoinPool.commonPool-worker-2]map: c2 [ForkJoinPool.commonPool-worker-3]sort: A2 &lt;&gt; A1 [main]sort: B1 &lt;&gt; A2 [main]sort: C2 &lt;&gt; B1 [main]sort: C1 &lt;&gt; C2 [main]sort: C1 &lt;&gt; B1 [main]sort: C1 &lt;&gt; C2 [main]forEach: A1 [ForkJoinPool.commonPool-worker-1]forEach: C2 [ForkJoinPool.commonPool-worker-3]forEach: B1 [main]forEach: A2 [ForkJoinPool.commonPool-worker-2]forEach: C1 [ForkJoinPool.commonPool-worker-1] 似乎sort只在主线程上顺序执行。实际上，sort在并行流上，在后台使用了新的Java 8方法Arrays.parallelSort()。如Javadoc中所述，此方法决定数组的长度是排序是顺序执行还是并行执行： 如果指定数组的长度小于最小粒度，则使用适当的Arrays.sort方法对其进行排序。 回到上reduce一节的示例。我们已经发现，组合器函数仅在并行流中调用，而不在顺序流中调用。让我们看看实际涉及到哪些线程： 12345678910111213141516171819List&lt;Person&gt; persons = Arrays.asList( new Person(\"Max\", 18), new Person(\"Peter\", 23), new Person(\"Pamela\", 23), new Person(\"David\", 12));persons .parallelStream() .reduce(0, (sum, p) -&gt; &#123; System.out.format(\"accumulator: sum=%s; person=%s [%s]\\n\", sum, p, Thread.currentThread().getName()); return sum += p.age; &#125;, (sum1, sum2) -&gt; &#123; System.out.format(\"combiner: sum1=%s; sum2=%s [%s]\\n\", sum1, sum2, Thread.currentThread().getName()); return sum1 + sum2; &#125;); 控制台输出显示，累加器和合并器函数在所有可用线程上并行执行： 1234567accumulator: sum=0; person=Pamela; [main]accumulator: sum=0; person=Max; [ForkJoinPool.commonPool-worker-3]accumulator: sum=0; person=David; [ForkJoinPool.commonPool-worker-2]accumulator: sum=0; person=Peter; [ForkJoinPool.commonPool-worker-1]combiner: sum1=18; sum2=23; [ForkJoinPool.commonPool-worker-1]combiner: sum1=23; sum2=12; [ForkJoinPool.commonPool-worker-2]combiner: sum1=41; sum2=35; [ForkJoinPool.commonPool-worker-2] 总之，可以说并行流可以为具有大量输入元素的流带来不错的性能提升。但是，请记住，像一些并行流操作reduce，并collect需要额外的计算（组合操作）时，依次执行其中不需要。 此外，我们了解到所有并行流操作共享相同的JVM范围的common ForkJoinPool。因此，您可能要避免实施缓慢的阻塞流操作，因为这有可能减慢应用程序中严重依赖并行流的其他部分的速度。 https://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/#different-kind-of-streams 的翻译版","categories":[{"name":"Java","slug":"Java","permalink":"https://lzyb.github.io/categories/Java/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"https://lzyb.github.io/tags/Java8/"},{"name":"Stream流","slug":"Stream流","permalink":"https://lzyb.github.io/tags/Stream%E6%B5%81/"}]},{"title":"Java 函数式接口","slug":"Java-函数式接口","date":"2017-04-07T08:52:19.000Z","updated":"2020-05-11T02:02:31.391Z","comments":true,"path":"2017/04/07/Java-函数式接口/","link":"","permalink":"https://lzyb.github.io/2017/04/07/Java-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/","excerpt":"Java 8 函数式接口函数接口概述函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口可以被隐式转换为 lambda 表达式。Lambda 表达式和方法引用（实际上也可认为是Lambda表达式）上。","text":"Java 8 函数式接口函数接口概述函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口可以被隐式转换为 lambda 表达式。Lambda 表达式和方法引用（实际上也可认为是Lambda表达式）上。 函数接口定义如定义了一个函数式接口如下： 12345@FunctionalInterfaceinterface GreetingService &#123; void sayMessage(String message);&#125; 那么就可以使用Lambda表达式来表示该接口的一个实现(注：JAVA 8 之前一般是用匿名类实现的)： 1GreetingService greetService1 = message -&gt; System.out.println(\"Hello \" + message); @FunctionalInterface注解与@Override 注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解： @FunctionalInterface 。该注解可用于一个接口的定义上，一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要注意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。 lambda表达式(参数列表)-&gt;{代码} 常用函数式接口supplier生产数据函数式接口Supplier 接口翻译过来就是提供者，目的是生产数据，该接口对应的方法类型为不接受参数，但是提供一个返回值，通俗的理解为这种接口是无私的奉献者，不仅不要参数，还返回一个值，使用get()方法获得这个返回值。 1234public static void main(String[] args) &#123; Supplier&lt;String&gt; getInstance = () -&gt; \"HelloWorld!\"; System.out.println(getInstance.get());&#125; Consumer消费函数式接口该接口对应的方法类型为接收一个参数，没有返回值，可以通俗的理解成将这个参数’消费掉了’，一般来说使用Consumer接口往往伴随着一些期望状态的改变或者事件的发生，例如最典型的forEach就是使用的Consumer接口，虽然没有任何的返回值，但是却向控制台输出了语句。Consumer 使用accept对参数执行行为。 1234567891011121314accept(T t)public static void main(String[] args) &#123; StringBuilder sb = new StringBuilder(\"Hello \"); Consumer&lt;StringBuilder&gt; consumer = (str) -&gt; str.append(\"Jack!\"); consumer.accept(sb); System.out.println(sb.toString()); // Hello Jack!&#125;andThen(Consumer&lt;? super T&gt; after)public static void main(String[] args) &#123; Consumer&lt;StringBuilder&gt; consumer1 = (str) -&gt; str.append(\" Bob!\"); consumer.andThen(consumer1).accept(sb); System.out.println(sb.toString()); // Hello Jack! Bob&#125; Functio&lt;T,R&gt; 类型转换函数式接口T—函数的输入类型，R-函数的输出类型，也就是通过这个函数，可以将一个类型转换为另一个类型，比如下面的例子 12345678910111213apply(T t) public static void main(String[] args) &#123; Function&lt;String, String&gt; function = a -&gt; a + \" Jack!\"; System.out.println(function.apply(\"Hello\")); // Hello Jack!&#125; andThen(Function&lt;? super R,? extends V&gt; after) public static void main(String[] args) &#123; Function&lt;String, String&gt; function = a -&gt; a + \" Jack!\"; Function&lt;String, String&gt; function1 = a -&gt; a + \" Bob!\"; String greet = function.andThen(function1).apply(\"Hello\"); System.out.println(greet); // Hello Jack! Bob! &#125; Predicate 断言函数式接口predicate&lt;T,Boolean&gt; 断言接口，顾名思义，中文中的‘是’与‘不是’是中文语法的谓语，同样的该接口对应的方法为接收一个参数，返回一个Boolean类型值，多用于判断与过滤，当然你可以把他理解成特殊的Funcation&lt;T,R&gt;，但是为了便于区分语义，还是单独的划了一个接口，使用test()方法执行这段行为 1234567891011121314151617181920 public static void main(String[] args) &#123; Predicate&lt;Integer&gt; predicate = number -&gt; number != 0; test(T t) 等价于 == System.out.println(predicate.test(10)); //true and(Predicate&lt;? super T&gt; other) 等价于 and predicate = predicate.and(number -&gt; number &gt;= 10); System.out.println(predicate.test(10)); //true or(Predicate&lt;? super T&gt; other) 等价于 or predicate = predicate.or(number -&gt; number != 10); System.out.println(predicate.test(10)); //true negate() 等价于 != predicate = predicate.negate(); System.out.println(predicate.test(10)); //false&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://lzyb.github.io/categories/Java/"}],"tags":[{"name":"函数式接口","slug":"函数式接口","permalink":"https://lzyb.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"},{"name":"接口","slug":"接口","permalink":"https://lzyb.github.io/tags/%E6%8E%A5%E5%8F%A3/"},{"name":"Java8","slug":"Java8","permalink":"https://lzyb.github.io/tags/Java8/"}]},{"title":"Java 双列集合","slug":"Java-双列集合","date":"2017-03-21T02:43:43.000Z","updated":"2020-05-07T09:03:35.425Z","comments":true,"path":"2017/03/21/Java-双列集合/","link":"","permalink":"https://lzyb.github.io/2017/03/21/Java-%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88/","excerpt":"Map接口概述Map是双列集合的顶层接口，Map接口下是一个键值对（key-value）的映射接口，Map集合中，不能包含重复的键，每个键只能映射一个值（元素），值可以重复，因此可以根据key快速查找value的值。","text":"Map接口概述Map是双列集合的顶层接口，Map接口下是一个键值对（key-value）的映射接口，Map集合中，不能包含重复的键，每个键只能映射一个值（元素），值可以重复，因此可以根据key快速查找value的值。 Map接口常用的方法1、void clear() 从该地图中删除所有的映射（可选操作）。2、boolean containsKey(Object key) 如果此映射包含指定键的映射，则返回 true 。3、boolean containsValue(Object value) 如果此地图将一个或多个键映射到指定的值，则返回 true 。4、Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此地图中包含的映射的Set视图。5、Set&lt;K&gt; keySet()返回此地图中包含的键的Set视图。6、V put(K key, V value) 将指定的值与该映射中的指定键相关联（可选操作）。7、V remove(Object key) 如果存在（从可选的操作），从该地图中删除一个键的映射。8、int size() 返回此地图中键值映射的数量。 常用实现类Class HashMap&lt;K,V&gt;基于哈希表的实现的Map接口。 此实现提供了所有可选的地图操作，并允许null的值和null键。 （ HashMap类大致相当于Hashtable ，除了它是不同步的，并允许null）。这个类不能保证地图的顺序; 特别是，它不能保证订单在一段时间内保持不变。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安的能力，或者使用ConcurrentHashMap。HashMap在JDK1.8之前的实现方式 数组+链表,但是在JDK1.8后对HashMap进行了底层优化,改为了由 数组+链表+红黑树实现,主要的目的是提高查找效率。 Class LinkedHashMap&lt;K,V&gt;LinkedHashMap继承于HashMap，哈希表和链表实现的Map接口，具有可预测的迭代次序。 这种实现不同于HashMap，它维持于所有条目的运行双向链表。 此链接列表定义迭代排序，通常是将键插入到地图（插入顺序 ）中的顺序 。 请注意，如果将键重新插入到地图中，则插入顺序不受影响。 （A键k被重新插入到地图m如果当m.containsKey(k)将返回true之前立即调用m.put(k, v)被调用。） Class Hashtable&lt;K,V&gt;该类实现了一个哈希表，它将键映射到值。 任何非null对象都可以用作键值或值。为了从散列表成功存储和检索对象，用作键的对象必须实现hashCode方法和equals方法。Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。 TreeMap一个红黑树基于NavigableMap实现。 该地图是根据排序natural ordering其密钥，或通过Comparator在地图创建时提供，这取决于所使用的构造方法。TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。","categories":[{"name":"Java","slug":"Java","permalink":"https://lzyb.github.io/categories/Java/"}],"tags":[{"name":"集合","slug":"集合","permalink":"https://lzyb.github.io/tags/%E9%9B%86%E5%90%88/"},{"name":"双列集合","slug":"双列集合","permalink":"https://lzyb.github.io/tags/%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88/"},{"name":"Map","slug":"Map","permalink":"https://lzyb.github.io/tags/Map/"}]},{"title":"Java 单列集合","slug":"Java-单列集合","date":"2017-03-20T06:34:05.000Z","updated":"2020-05-07T09:12:29.524Z","comments":true,"path":"2017/03/20/Java-单列集合/","link":"","permalink":"https://lzyb.github.io/2017/03/20/Java-%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88/","excerpt":"集合集合类的特点：提供一种存储空间可变的存储模式存储的数据容量可以随时发生改变。和数组的区别：数组是存储同种数据类型、长度在定义后便不可变。集合分为单列集合(Collection)和双列集合(Map)","text":"集合集合类的特点：提供一种存储空间可变的存储模式存储的数据容量可以随时发生改变。和数组的区别：数组是存储同种数据类型、长度在定义后便不可变。集合分为单列集合(Collection)和双列集合(Map) Collection集合的概述Collection是单列集合的顶层接口，它表示一组对象，这些对象也称为Collection的元素；JDK不提供此接口的任何直接实现，它提供更具体的子接口(如Set、List)实现。 Collection常用的方法添加元素boolean add()、移除boolean remove()、清空void clear()、判断集合是否存在某个元素boolean contains()、判断集合是否为空boolean sEmpty()、获取集合的长度int size()。 Collection集合的遍历(迭代器)迭代器的介绍：是集合的专用遍历方式，通过集合的iterator iterator()方法得到。 迭代器的方法：hasNext()方法判断迭代中是否还有元素。如果有则调用next()方法返 下一个元素。值得一提的是增强for循环本质就是一个迭代器。 Collection集合按照不同的特点可分为两类子集合List和Set List集合List集合的特点：有序(元素的存储顺序一致)、有索引、可重复。 List集合的常用方法：void add()、remove()、set()、get()。都是基于索引进行的增删改查。 列表迭代器：List集合的特有遍历，通过listIterator()方法得到。主要用途是可以沿着任一方向进行遍历，逆向方法hasPrevious()，Previous()。值得注意的是列表迭代器在迭代期间修改列表，返回迭代器的当前位置，所以在进行逆向遍历前先进行正向遍历。 List集合的两个实现类：ArrayList：底层是数组，查询快，增删慢，线程不同步，效率高。 LinkedList：底层是链表，增删快，查询慢，线程不同步，效率高。特有方法first()可以获取(删除，得到)列表的一个元素，Last()同理。 Set集合Set集合的特点：无序，无索引(所以没有普通for循环)，唯一(不可重复) 哈希值哈希值的概念：是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值。 如何获取哈希值：通过object类中的hashcode()：返回对象的哈希值； 哈希值的特点：1、同一个对象调用hashCode()方法返回的哈希值是相同的；2、不同的对象可以通过重写hashCode()方法得到相同的哈希值。 Set集合的三个实现类：HashSet：底层是哈希表，无序，无索引(不能使用普通for),hashcode保证唯一性 LinkedHashSet：底层是哈希表和链表，有序，无索引，唯一。 TreeSet：底层是二叉树，有序(指按照一定规则排序)，无索引，唯一。 自然排序：实现compareable接口，复写compareTo方法，当主要条件相等时要比较次要元素，保证唯一性的语句是compareTo方法return0 比较器排序：当元素不具备比较性，或者具备的比较性不符合需求，那么就让集合自身具备比较性，定义一个类实现Compare接口，重写compare()方法。","categories":[{"name":"Java","slug":"Java","permalink":"https://lzyb.github.io/categories/Java/"}],"tags":[{"name":"集合","slug":"集合","permalink":"https://lzyb.github.io/tags/%E9%9B%86%E5%90%88/"},{"name":"单列集合","slug":"单列集合","permalink":"https://lzyb.github.io/tags/%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88/"},{"name":"Collection","slug":"Collection","permalink":"https://lzyb.github.io/tags/Collection/"}]}],"categories":[{"name":"生活","slug":"生活","permalink":"https://lzyb.github.io/categories/%E7%94%9F%E6%B4%BB/"},{"name":"Git","slug":"Git","permalink":"https://lzyb.github.io/categories/Git/"},{"name":"Java","slug":"Java","permalink":"https://lzyb.github.io/categories/Java/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://lzyb.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"Git","slug":"Git","permalink":"https://lzyb.github.io/tags/Git/"},{"name":"常用命令","slug":"常用命令","permalink":"https://lzyb.github.io/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"name":"Java8","slug":"Java8","permalink":"https://lzyb.github.io/tags/Java8/"},{"name":"Stream流","slug":"Stream流","permalink":"https://lzyb.github.io/tags/Stream%E6%B5%81/"},{"name":"函数式接口","slug":"函数式接口","permalink":"https://lzyb.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"},{"name":"接口","slug":"接口","permalink":"https://lzyb.github.io/tags/%E6%8E%A5%E5%8F%A3/"},{"name":"集合","slug":"集合","permalink":"https://lzyb.github.io/tags/%E9%9B%86%E5%90%88/"},{"name":"双列集合","slug":"双列集合","permalink":"https://lzyb.github.io/tags/%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88/"},{"name":"Map","slug":"Map","permalink":"https://lzyb.github.io/tags/Map/"},{"name":"单列集合","slug":"单列集合","permalink":"https://lzyb.github.io/tags/%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88/"},{"name":"Collection","slug":"Collection","permalink":"https://lzyb.github.io/tags/Collection/"}]}