<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>李昊的站</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lzyb.github.io/"/>
  <updated>2020-05-06T09:37:24.648Z</updated>
  <id>https://lzyb.github.io/</id>
  
  <author>
    <name>Li Hao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>吟诗一首</title>
    <link href="https://lzyb.github.io/2020/04/26/2020/04/26%E9%9A%8F%E7%AC%94/"/>
    <id>https://lzyb.github.io/2020/04/26/2020/04/26%E9%9A%8F%E7%AC%94/</id>
    <published>2020-04-26T13:32:42.000Z</published>
    <updated>2020-05-06T09:37:24.648Z</updated>
    
    <content type="html"><![CDATA[  <center> 三十而立已到中年，技术平平且不善言辞。</center>  <center> ​每逢面试十面九散，未来何期也诚惶诚恐。</center>   <a id="more"></a>   <center>数十余年人在漂泊，碌碌无为还不知不觉。</center>  <center> ​二零一九新冠肺炎，方然顿悟欲难欲要抗。</center>   <center>便是一生无功与名，愿为妻儿换一世太平。</center>   <center>摘自V2EX有感</center>]]></content>
    
    <summary type="html">
    
      &lt;center&gt; 三十而立已到中年，技术平平且不善言辞。&lt;/center&gt;
  &lt;center&gt; ​每逢面试十面九散，未来何期也诚惶诚恐。&lt;/center&gt;
    
    </summary>
    
    
      <category term="生活" scheme="https://lzyb.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="https://lzyb.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Java 函数式接口</title>
    <link href="https://lzyb.github.io/2017/04/07/Java-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
    <id>https://lzyb.github.io/2017/04/07/Java-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/</id>
    <published>2017-04-07T08:52:19.000Z</published>
    <updated>2020-05-07T10:00:15.338Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-8-函数式接口"><a href="#Java-8-函数式接口" class="headerlink" title="Java 8 函数式接口"></a>Java 8 函数式接口</h2><h3 id="函数接口概述"><a href="#函数接口概述" class="headerlink" title="函数接口概述"></a>函数接口概述</h3><p>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。<br>函数式接口可以被隐式转换为 lambda 表达式。<br>Lambda 表达式和方法引用（实际上也可认为是Lambda表达式）上。</p><a id="more"></a><h3 id="函数接口定义"><a href="#函数接口定义" class="headerlink" title="函数接口定义"></a>函数接口定义</h3><p>如定义了一个函数式接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GreetingService</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么就可以使用Lambda表达式来表示该接口的一个实现(注：JAVA 8 之前一般是用匿名类实现的)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GreetingService greetService1 = message -&gt; System.out.println(<span class="string">"Hello "</span> + message);</span><br></pre></td></tr></table></figure><h4 id="FunctionalInterface注解"><a href="#FunctionalInterface注解" class="headerlink" title="@FunctionalInterface注解"></a>@FunctionalInterface注解</h4><p>与@Override 注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解： @FunctionalInterface 。该注解可用于一个接口的定义上，一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要注意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。</p><h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p>(参数列表)-&gt;{代码}</p><h3 id="常用函数式接口"><a href="#常用函数式接口" class="headerlink" title="常用函数式接口"></a>常用函数式接口</h3><h4 id="supplier生产数据函数式接口"><a href="#supplier生产数据函数式接口" class="headerlink" title="supplier生产数据函数式接口"></a>supplier生产数据函数式接口</h4><p>Supplier 接口翻译过来就是提供者，目的是生产数据，该接口对应的方法类型为不接受参数，但是提供一个返回值，通俗的理解为这种接口是无私的奉献者，不仅不要参数，还返回一个值，使用get()方法获得这个返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Supplier&lt;String&gt; getInstance = () -&gt; <span class="string">"HelloWorld!"</span>;</span><br><span class="line">    System.out.println(getInstance.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Consumer消费函数式接口"><a href="#Consumer消费函数式接口" class="headerlink" title="Consumer消费函数式接口"></a>Consumer消费函数式接口</h4><p>该接口对应的方法类型为接收一个参数，没有返回值，可以通俗的理解成将这个参数’消费掉了’，一般来说使用Consumer接口往往伴随着一些期望状态的改变或者事件的发生，例如最典型的forEach就是使用的Consumer接口，虽然没有任何的返回值，但是却向控制台输出了语句。<br>Consumer 使用accept对参数执行行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">accept(T t)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"Hello "</span>);</span><br><span class="line">    Consumer&lt;StringBuilder&gt; consumer = (str) -&gt; str.append(<span class="string">"Jack!"</span>);</span><br><span class="line">    consumer.accept(sb);</span><br><span class="line">    System.out.println(sb.toString());<span class="comment">// Hello Jack!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">andThen(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Consumer&lt;StringBuilder&gt; consumer1 = (str) -&gt; str.append(<span class="string">" Bob!"</span>);</span><br><span class="line">    consumer.andThen(consumer1).accept(sb);</span><br><span class="line">    System.out.println(sb.toString());<span class="comment">// Hello Jack! Bob</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Functio-lt-T-R-gt-类型转换函数式接口"><a href="#Functio-lt-T-R-gt-类型转换函数式接口" class="headerlink" title="Functio&lt;T,R&gt; 类型转换函数式接口"></a>Functio&lt;T,R&gt; 类型转换函数式接口</h4><p>T—函数的输入类型，R-函数的输出类型，也就是通过这个函数，可以将一个类型转换为另一个类型，比如下面的例子<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apply(T t)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Function&lt;String, String&gt; function = a -&gt; a + <span class="string">" Jack!"</span>;</span><br><span class="line">    System.out.println(function.apply(<span class="string">"Hello"</span>)); <span class="comment">// Hello Jack!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> andThen(Function&lt;? <span class="keyword">super</span> R,? extends V&gt; after)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Function&lt;String, String&gt; function = a -&gt; a + <span class="string">" Jack!"</span>;</span><br><span class="line">    Function&lt;String, String&gt; function1 = a -&gt; a + <span class="string">" Bob!"</span>;</span><br><span class="line">    String greet = function.andThen(function1).apply(<span class="string">"Hello"</span>);</span><br><span class="line">    System.out.println(greet); <span class="comment">// Hello Jack! Bob!</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h4 id="Predicate-断言函数式接口"><a href="#Predicate-断言函数式接口" class="headerlink" title="Predicate 断言函数式接口"></a>Predicate 断言函数式接口</h4><p>predicate&lt;T,Boolean&gt; 断言接口，顾名思义，中文中的‘是’与‘不是’是中文语法的谓语，同样的该接口对应的方法为接收一个参数，返回一个Boolean类型值，多用于判断与过滤，当然你可以把他理解成特殊的Funcation&lt;T,R&gt;，但是为了便于区分语义，还是单独的划了一个接口，使用test()方法执行这段行为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   Predicate&lt;Integer&gt; predicate = number -&gt; number != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    test(T t) 等价于 ==</span><br><span class="line">    System.out.println(predicate.test(<span class="number">10</span>));    <span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">    and(Predicate&lt;? <span class="keyword">super</span> T&gt; other) 等价于 and</span><br><span class="line">    predicate = predicate.and(number -&gt; number &gt;= <span class="number">10</span>);</span><br><span class="line">    System.out.println(predicate.test(<span class="number">10</span>));    <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    or(Predicate&lt;? <span class="keyword">super</span> T&gt; other) 等价于 or</span><br><span class="line">    predicate = predicate.or(number -&gt; number != <span class="number">10</span>);</span><br><span class="line">    System.out.println(predicate.test(<span class="number">10</span>));    <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    negate() 等价于 !=</span><br><span class="line">    predicate = predicate.negate();</span><br><span class="line">    System.out.println(predicate.test(<span class="number">10</span>));    <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java-8-函数式接口&quot;&gt;&lt;a href=&quot;#Java-8-函数式接口&quot; class=&quot;headerlink&quot; title=&quot;Java 8 函数式接口&quot;&gt;&lt;/a&gt;Java 8 函数式接口&lt;/h2&gt;&lt;h3 id=&quot;函数接口概述&quot;&gt;&lt;a href=&quot;#函数接口概述&quot; class=&quot;headerlink&quot; title=&quot;函数接口概述&quot;&gt;&lt;/a&gt;函数接口概述&lt;/h3&gt;&lt;p&gt;函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。&lt;br&gt;函数式接口可以被隐式转换为 lambda 表达式。&lt;br&gt;Lambda 表达式和方法引用（实际上也可认为是Lambda表达式）上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://lzyb.github.io/categories/Java/"/>
    
    
      <category term="函数式接口" scheme="https://lzyb.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
    
      <category term="接口" scheme="https://lzyb.github.io/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java 双列集合</title>
    <link href="https://lzyb.github.io/2017/03/21/Java-%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88/"/>
    <id>https://lzyb.github.io/2017/03/21/Java-%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88/</id>
    <published>2017-03-21T02:43:43.000Z</published>
    <updated>2020-05-07T09:03:35.425Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Map接口概述"><a href="#Map接口概述" class="headerlink" title="Map接口概述"></a>Map接口概述</h3><p>Map是双列集合的顶层接口，Map接口下是一个键值对（key-value）的映射接口，Map集合中，不能包含重复的键，每个键只能映射一个值（元素），值可以重复，因此可以根据key快速查找value的值。</p><a id="more"></a><h3 id="Map接口常用的方法"><a href="#Map接口常用的方法" class="headerlink" title="Map接口常用的方法"></a>Map接口常用的方法</h3><p>1、<code>void clear()</code>  从该地图中删除所有的映射（可选操作）。<br>2、<code>boolean containsKey(Object key)</code> 如果此映射包含指定键的映射，则返回 true 。<br>3、<code>boolean containsValue(Object value)</code> 如果此地图将一个或多个键映射到指定的值，则返回 true 。<br>4、<code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code> 返回此地图中包含的映射的Set视图。<br>5、<code>Set&lt;K&gt; keySet()</code>返回此地图中包含的键的Set视图。<br>6、<code>V     put(K key, V value)</code> 将指定的值与该映射中的指定键相关联（可选操作）。<br>7、<code>V    remove(Object key)</code> 如果存在（从可选的操作），从该地图中删除一个键的映射。<br>8、<code>int  size()</code> 返回此地图中键值映射的数量。</p><h3 id="常用实现类"><a href="#常用实现类" class="headerlink" title="常用实现类"></a>常用实现类</h3><h4 id="Class-HashMap-lt-K-V-gt"><a href="#Class-HashMap-lt-K-V-gt" class="headerlink" title="Class HashMap&lt;K,V&gt;"></a>Class HashMap&lt;K,V&gt;</h4><p>基于哈希表的实现的Map接口。 此实现提供了所有可选的地图操作，并允许null的值和null键。 （ HashMap类大致相当于Hashtable ，除了它是不同步的，并允许null）。这个类不能保证地图的顺序; 特别是，它不能保证订单在一段时间内保持不变。<br>HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安的能力，或者使用ConcurrentHashMap。<br>HashMap在JDK1.8之前的实现方式 数组+链表,但是在JDK1.8后对HashMap进行了底层优化,改为了由 数组+链表+红黑树实现,主要的目的是提高查找效率。</p><h4 id="Class-LinkedHashMap-lt-K-V-gt"><a href="#Class-LinkedHashMap-lt-K-V-gt" class="headerlink" title="Class LinkedHashMap&lt;K,V&gt;"></a>Class LinkedHashMap&lt;K,V&gt;</h4><p>LinkedHashMap继承于HashMap，哈希表和链表实现的Map接口，具有可预测的迭代次序。 这种实现不同于HashMap，它维持于所有条目的运行双向链表。 此链接列表定义迭代排序，通常是将键插入到地图（插入顺序 ）中的顺序 。 请注意，如果将键重新插入到地图中，则插入顺序不受影响。 （A键k被重新插入到地图m如果当m.containsKey(k)将返回true之前立即调用m.put(k, v)被调用。）</p><h4 id="Class-Hashtable-lt-K-V-gt"><a href="#Class-Hashtable-lt-K-V-gt" class="headerlink" title="Class Hashtable&lt;K,V&gt;"></a>Class Hashtable&lt;K,V&gt;</h4><p>该类实现了一个哈希表，它将键映射到值。 任何非null对象都可以用作键值或值。<br>为了从散列表成功存储和检索对象，用作键的对象必须实现hashCode方法和equals方法。<br>Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>一个红黑树基于NavigableMap实现。 该地图是根据排序natural ordering其密钥，或通过Comparator在地图创建时提供，这取决于所使用的构造方法。<br>TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Map接口概述&quot;&gt;&lt;a href=&quot;#Map接口概述&quot; class=&quot;headerlink&quot; title=&quot;Map接口概述&quot;&gt;&lt;/a&gt;Map接口概述&lt;/h3&gt;&lt;p&gt;Map是双列集合的顶层接口，Map接口下是一个键值对（key-value）的映射接口，Map集合中，不能包含重复的键，每个键只能映射一个值（元素），值可以重复，因此可以根据key快速查找value的值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://lzyb.github.io/categories/Java/"/>
    
    
      <category term="集合" scheme="https://lzyb.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="双列集合" scheme="https://lzyb.github.io/tags/%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88/"/>
    
      <category term="Map" scheme="https://lzyb.github.io/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>Java 单列集合</title>
    <link href="https://lzyb.github.io/2017/03/20/Java-%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88/"/>
    <id>https://lzyb.github.io/2017/03/20/Java-%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88/</id>
    <published>2017-03-20T06:34:05.000Z</published>
    <updated>2020-05-07T09:12:29.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合类的特点：提供一种存储空间可变的存储模式存储的数据容量可以随时发生改变。<br>和数组的区别：数组是存储同种数据类型、长度在定义后便不可变。<br>集合分为单列集合(Collection)和双列集合(Map)</p><a id="more"></a><h3 id="Collection集合的概述"><a href="#Collection集合的概述" class="headerlink" title="Collection集合的概述"></a>Collection集合的概述</h3><p>Collection是单列集合的顶层接口，它表示一组对象，这些对象也称为Collection的元素；JDK不提供此接口的任何直接实现，它提供更具体的子接口(如Set、List)实现。</p><h3 id="Collection常用的方法"><a href="#Collection常用的方法" class="headerlink" title="Collection常用的方法"></a>Collection常用的方法</h3><p>添加元素<code>boolean add()</code>、移除<code>boolean remove()</code>、清空<code>void clear()</code>、判断集合是否存在某个元素<code>boolean contains()</code>、判断集合是否为空<code>boolean sEmpty()</code>、获取集合的长度<code>int size()</code>。</p><h3 id="Collection集合的遍历-迭代器"><a href="#Collection集合的遍历-迭代器" class="headerlink" title="Collection集合的遍历(迭代器)"></a>Collection集合的遍历(迭代器)</h3><p>迭代器的介绍：是集合的专用遍历方式，通过集合的iterator iterator()方法得到。</p><p>迭代器的方法：hasNext()方法判断迭代中是否还有元素。如果有则调用next()方法返 下一个元素。值得一提的是增强for循环本质就是一个迭代器。</p><p>Collection集合按照不同的特点可分为两类子集合List和Set</p><h3 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h3><p>List集合的特点：有序(元素的存储顺序一致)、有索引、可重复。</p><p>List集合的常用方法：void add()、remove()、set()、get()。都是基于索引进行的增删改查。</p><p>列表迭代器：List集合的特有遍历，通过listIterator()方法得到。主要用途是可以沿着任一方向进行遍历，逆向方法hasPrevious()，Previous()。值得注意的是列表迭代器在迭代期间修改列表，返回迭代器的当前位置，所以在进行逆向遍历前先进行正向遍历。</p><h4 id="List集合的两个实现类："><a href="#List集合的两个实现类：" class="headerlink" title="List集合的两个实现类："></a>List集合的两个实现类：</h4><p>ArrayList：底层是数组，查询快，增删慢，线程不同步，效率高。</p><p>LinkedList：底层是链表，增删快，查询慢，线程不同步，效率高。特有方法first()可以获取(删除，得到)列表的一个元素，Last()同理。</p><h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><p>Set集合的特点：无序，无索引(所以没有普通for循环)，唯一(不可重复)</p><h4 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h4><p>哈希值的概念：是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值。</p><p>如何获取哈希值：通过object类中的hashcode()：返回对象的哈希值；</p><p>哈希值的特点：1、同一个对象调用hashCode()方法返回的哈希值是相同的；2、不同的对象可以通过重写hashCode()方法得到相同的哈希值。</p><h4 id="Set集合的三个实现类："><a href="#Set集合的三个实现类：" class="headerlink" title="Set集合的三个实现类："></a>Set集合的三个实现类：</h4><p>HashSet：底层是哈希表，无序，无索引(不能使用普通for),hashcode保证唯一性</p><p><img src="/img/hashset.png" alt="HashSet"></p><p>LinkedHashSet：底层是哈希表和链表，有序，无索引，唯一。</p><p>TreeSet：底层是二叉树，有序(指按照一定规则排序)，无索引，唯一。</p><p>自然排序：实现compareable接口，复写compareTo方法，当主要条件相等时要比较次要元素，保证唯一性的语句是compareTo方法return0</p><p>比较器排序：当元素不具备比较性，或者具备的比较性不符合需求，那么就让集合自身具备比较性，定义一个类实现Compare接口，重写compare()方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;集合&quot;&gt;&lt;a href=&quot;#集合&quot; class=&quot;headerlink&quot; title=&quot;集合&quot;&gt;&lt;/a&gt;集合&lt;/h2&gt;&lt;p&gt;集合类的特点：提供一种存储空间可变的存储模式存储的数据容量可以随时发生改变。&lt;br&gt;和数组的区别：数组是存储同种数据类型、长度在定义后便不可变。&lt;br&gt;集合分为单列集合(Collection)和双列集合(Map)&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://lzyb.github.io/categories/Java/"/>
    
    
      <category term="集合" scheme="https://lzyb.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="单列集合" scheme="https://lzyb.github.io/tags/%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88/"/>
    
      <category term="Collection" scheme="https://lzyb.github.io/tags/Collection/"/>
    
  </entry>
  
</feed>
